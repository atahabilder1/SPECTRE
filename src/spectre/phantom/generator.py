"""Bytecode generation strategies for differential fuzzing."""

from __future__ import annotations

import random
from abc import ABC, abstractmethod
from collections.abc import Iterator
from dataclasses import dataclass
from enum import Enum, auto

from ethereum.common.types import Opcode


class GeneratorStrategy(Enum):
    """Bytecode generation strategies."""

    RANDOM = auto()
    GRAMMAR = auto()
    BOUNDARY = auto()
    OPCODE_FOCUSED = auto()
    SEQUENCE = auto()


@dataclass
class GeneratedBytecode:
    """A generated bytecode sample."""

    code: bytes
    strategy: GeneratorStrategy
    description: str
    seed: int | None = None


class BytecodeGeneratorBase(ABC):
    """Base class for bytecode generators."""

    strategy: GeneratorStrategy

    @abstractmethod
    def generate(self, seed: int | None = None) -> GeneratedBytecode:
        """Generate a single bytecode sample."""
        pass

    def generate_batch(self, count: int, seed: int | None = None) -> Iterator[GeneratedBytecode]:
        """Generate multiple bytecode samples."""
        if seed is not None:
            random.seed(seed)
        for i in range(count):
            yield self.generate(seed=seed + i if seed else None)


class RandomBytecodeGenerator(BytecodeGeneratorBase):
    """Generate random bytecode sequences."""

    strategy = GeneratorStrategy.RANDOM

    def __init__(
        self,
        min_length: int = 1,
        max_length: int = 100,
    ) -> None:
        self.min_length = min_length
        self.max_length = max_length

    def generate(self, seed: int | None = None) -> GeneratedBytecode:
        if seed is not None:
            random.seed(seed)

        length = random.randint(self.min_length, self.max_length)
        code = bytes(random.randint(0, 255) for _ in range(length))

        return GeneratedBytecode(
            code=code,
            strategy=self.strategy,
            description=f"Random {length} bytes",
            seed=seed,
        )


class GrammarBytecodeGenerator(BytecodeGeneratorBase):
    """Generate syntactically valid bytecode using grammar rules."""

    strategy = GeneratorStrategy.GRAMMAR

    # Opcodes grouped by stack behavior
    PUSH_OPCODES = list(range(Opcode.PUSH1, Opcode.PUSH32 + 1))
    DUP_OPCODES = list(range(Opcode.DUP1, Opcode.DUP16 + 1))
    SWAP_OPCODES = list(range(Opcode.SWAP1, Opcode.SWAP16 + 1))

    ARITHMETIC_OPCODES = [
        Opcode.ADD,
        Opcode.MUL,
        Opcode.SUB,
        Opcode.DIV,
        Opcode.SDIV,
        Opcode.MOD,
        Opcode.SMOD,
        Opcode.ADDMOD,
        Opcode.MULMOD,
        Opcode.EXP,
    ]

    COMPARISON_OPCODES = [
        Opcode.LT,
        Opcode.GT,
        Opcode.SLT,
        Opcode.SGT,
        Opcode.EQ,
        Opcode.ISZERO,
    ]

    BITWISE_OPCODES = [
        Opcode.AND,
        Opcode.OR,
        Opcode.XOR,
        Opcode.NOT,
        Opcode.BYTE,
        Opcode.SHL,
        Opcode.SHR,
        Opcode.SAR,
    ]

    MEMORY_OPCODES = [
        Opcode.MLOAD,
        Opcode.MSTORE,
        Opcode.MSTORE8,
    ]

    TERMINATING_OPCODES = [
        Opcode.STOP,
        Opcode.RETURN,
        Opcode.REVERT,
    ]

    def __init__(self, max_depth: int = 20) -> None:
        self.max_depth = max_depth

    def _push_value(self, value: int) -> bytes:
        """Generate PUSH instruction for value."""
        if value == 0:
            return bytes([Opcode.PUSH1, 0])
        byte_length = (value.bit_length() + 7) // 8
        byte_length = min(byte_length, 32)
        opcode = Opcode.PUSH1 + byte_length - 1
        value_bytes = value.to_bytes(byte_length, "big")
        return bytes([opcode]) + value_bytes

    def generate(self, seed: int | None = None) -> GeneratedBytecode:
        if seed is not None:
            random.seed(seed)

        code = bytearray()
        stack_depth = 0

        for _ in range(random.randint(5, self.max_depth)):
            # Choose operation based on stack state
            if stack_depth < 2:
                # Need to push values
                value = random.choice([0, 1, 255, 256, 2**255 - 1, 2**256 - 1])
                code.extend(self._push_value(value % (2**256)))
                stack_depth += 1
            else:
                # Can do operations
                op_type = random.choice(
                    ["arithmetic", "comparison", "bitwise", "dup", "swap", "push"]
                )

                if op_type == "arithmetic" and stack_depth >= 2:
                    op = random.choice(self.ARITHMETIC_OPCODES)
                    code.append(op)
                    stack_depth -= 1  # Binary op consumes 2, produces 1
                elif op_type == "comparison" and stack_depth >= 2:
                    op = random.choice(self.COMPARISON_OPCODES)
                    code.append(op)
                    stack_depth -= 1
                elif op_type == "bitwise" and stack_depth >= 2:
                    op = random.choice(self.BITWISE_OPCODES)
                    if op == Opcode.NOT:
                        code.append(op)
                        # Unary, no stack change
                    else:
                        code.append(op)
                        stack_depth -= 1
                elif op_type == "dup" and stack_depth >= 1:
                    max_dup = min(stack_depth, 16)
                    n = random.randint(1, max_dup)
                    code.append(Opcode.DUP1 + n - 1)
                    stack_depth += 1
                elif op_type == "swap" and stack_depth >= 2:
                    max_swap = min(stack_depth - 1, 16)
                    n = random.randint(1, max_swap)
                    code.append(Opcode.SWAP1 + n - 1)
                else:
                    value = random.randint(0, 255)
                    code.extend(self._push_value(value))
                    stack_depth += 1

        # Always terminate properly
        code.append(Opcode.STOP)

        return GeneratedBytecode(
            code=bytes(code),
            strategy=self.strategy,
            description=f"Grammar-based {len(code)} bytes",
            seed=seed,
        )


class BoundaryBytecodeGenerator(BytecodeGeneratorBase):
    """Generate bytecode that tests boundary conditions."""

    strategy = GeneratorStrategy.BOUNDARY

    BOUNDARY_VALUES = [
        0,
        1,
        127,
        128,
        255,
        256,
        2**15 - 1,
        2**15,
        2**16 - 1,
        2**16,
        2**32 - 1,
        2**32,
        2**64 - 1,
        2**64,
        2**128 - 1,
        2**128,
        2**255 - 1,
        2**255,
        2**256 - 1,
    ]

    def _push_value(self, value: int) -> bytes:
        """Generate PUSH instruction for value."""
        if value == 0:
            return bytes([Opcode.PUSH1, 0])
        byte_length = (value.bit_length() + 7) // 8
        byte_length = min(byte_length, 32)
        opcode = Opcode.PUSH1 + byte_length - 1
        value_bytes = value.to_bytes(byte_length, "big")
        return bytes([opcode]) + value_bytes

    def generate(self, seed: int | None = None) -> GeneratedBytecode:
        if seed is not None:
            random.seed(seed)

        code = bytearray()

        # Pick random boundary values
        values = random.sample(self.BOUNDARY_VALUES, min(3, len(self.BOUNDARY_VALUES)))

        for value in values:
            code.extend(self._push_value(value))

        # Add an operation
        ops = [Opcode.ADD, Opcode.SUB, Opcode.MUL, Opcode.DIV, Opcode.EXP]
        code.append(random.choice(ops))
        code.append(Opcode.STOP)

        return GeneratedBytecode(
            code=bytes(code),
            strategy=self.strategy,
            description=f"Boundary test with values {values}",
            seed=seed,
        )


class OpcodeFocusedGenerator(BytecodeGeneratorBase):
    """Generate bytecode focused on specific opcodes."""

    strategy = GeneratorStrategy.OPCODE_FOCUSED

    def __init__(self, target_opcodes: list[int] | None = None) -> None:
        self.target_opcodes = target_opcodes or [Opcode.PUSH0]

    def _push_value(self, value: int) -> bytes:
        """Generate PUSH instruction for value."""
        if value == 0:
            return bytes([Opcode.PUSH1, 0])
        byte_length = (value.bit_length() + 7) // 8
        byte_length = min(byte_length, 32)
        opcode = Opcode.PUSH1 + byte_length - 1
        value_bytes = value.to_bytes(byte_length, "big")
        return bytes([opcode]) + value_bytes

    def generate(self, seed: int | None = None) -> GeneratedBytecode:
        if seed is not None:
            random.seed(seed)

        code = bytearray()

        # Setup context
        for _ in range(random.randint(1, 3)):
            code.extend(self._push_value(random.randint(0, 255)))

        # Add target opcode
        target = random.choice(self.target_opcodes)
        code.append(target)

        # Handle opcode-specific data
        if Opcode.PUSH1 <= target <= Opcode.PUSH32:
            size = target - Opcode.PUSH1 + 1
            code.extend(bytes(random.randint(0, 255) for _ in range(size)))

        code.append(Opcode.STOP)

        return GeneratedBytecode(
            code=bytes(code),
            strategy=self.strategy,
            description=f"Focused on opcode 0x{target:02X}",
            seed=seed,
        )


class SequenceGenerator(BytecodeGeneratorBase):
    """Generate specific opcode sequences for targeted testing."""

    strategy = GeneratorStrategy.SEQUENCE

    SEQUENCES = [
        # Stack manipulation
        [Opcode.PUSH1, 0x01, Opcode.PUSH1, 0x02, Opcode.SWAP1, Opcode.STOP],
        # Memory operations
        [Opcode.PUSH1, 0x42, Opcode.PUSH1, 0x00, Opcode.MSTORE, Opcode.STOP],
        # Arithmetic edge case
        [Opcode.PUSH32] + [0xFF] * 32 + [Opcode.PUSH1, 0x01, Opcode.ADD, Opcode.STOP],
        # Division by zero
        [Opcode.PUSH1, 0x00, Opcode.PUSH1, 0x42, Opcode.DIV, Opcode.STOP],
        # Jump operations
        [Opcode.PUSH1, 0x04, Opcode.JUMP, Opcode.INVALID, Opcode.JUMPDEST, Opcode.STOP],
    ]

    def generate(self, seed: int | None = None) -> GeneratedBytecode:
        if seed is not None:
            random.seed(seed)

        sequence = random.choice(self.SEQUENCES)
        code = bytes(sequence)

        return GeneratedBytecode(
            code=code,
            strategy=self.strategy,
            description="Predefined sequence",
            seed=seed,
        )


class BytecodeGenerator:
    """Main bytecode generator combining all strategies."""

    def __init__(
        self,
        strategies: list[GeneratorStrategy] | None = None,
    ) -> None:
        self.generators: dict[GeneratorStrategy, BytecodeGeneratorBase] = {
            GeneratorStrategy.RANDOM: RandomBytecodeGenerator(),
            GeneratorStrategy.GRAMMAR: GrammarBytecodeGenerator(),
            GeneratorStrategy.BOUNDARY: BoundaryBytecodeGenerator(),
            GeneratorStrategy.OPCODE_FOCUSED: OpcodeFocusedGenerator(),
            GeneratorStrategy.SEQUENCE: SequenceGenerator(),
        }
        self.strategies = strategies or list(GeneratorStrategy)

    def generate(
        self,
        count: int = 100,
        seed: int | None = None,
    ) -> Iterator[GeneratedBytecode]:
        """Generate bytecode samples using mixed strategies."""
        if seed is not None:
            random.seed(seed)

        for i in range(count):
            strategy = random.choice(self.strategies)
            generator = self.generators[strategy]
            yield generator.generate(seed=seed + i if seed else None)

    def generate_for_eip(
        self,
        eip_number: int,
        count: int = 50,
    ) -> Iterator[GeneratedBytecode]:
        """Generate bytecode focused on testing a specific EIP."""
        # EIP-specific opcode targets
        eip_opcodes = {
            2: [Opcode.CREATE, Opcode.CALL],  # Homestead CREATE changes
            3855: [Opcode.PUSH0],  # PUSH0
            145: [Opcode.SHL, Opcode.SHR, Opcode.SAR],  # Bitwise shifts
            1014: [Opcode.CREATE2],  # CREATE2
        }

        opcodes = eip_opcodes.get(eip_number, [])
        if opcodes:
            generator = OpcodeFocusedGenerator(opcodes)
            yield from generator.generate_batch(count)
        else:
            # Fall back to grammar-based generation
            generator = GrammarBytecodeGenerator()
            yield from generator.generate_batch(count)
